// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: homepage_banners.sql

package generated

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
)

const deleteHomepageBanner = `-- name: DeleteHomepageBanner :exec
DELETE FROM homepage_banners
WHERE id = $1
`

func (q *Queries) DeleteHomepageBanner(ctx context.Context, id uuid.UUID) error {
	_, err := q.exec(ctx, q.deleteHomepageBannerStmt, deleteHomepageBanner, id)
	return err
}

const insertHomepageBanner = `-- name: InsertHomepageBanner :one
INSERT INTO homepage_banners (
  id,
  title,
  subtitle,
  media_id,
  cta_text,
  cta_url,
  is_active,
  start_date,
  end_date
) VALUES (
  $1, $2, $3, $4, $5, $6, $7, $8, $9
)
RETURNING id, title, subtitle, media_id, cta_text, cta_url, is_active, start_date, end_date, created_at
`

type InsertHomepageBannerParams struct {
	ID        uuid.UUID      `json:"id"`
	Title     sql.NullString `json:"title"`
	Subtitle  sql.NullString `json:"subtitle"`
	MediaID   uuid.NullUUID  `json:"media_id"`
	CtaText   sql.NullString `json:"cta_text"`
	CtaUrl    sql.NullString `json:"cta_url"`
	IsActive  sql.NullBool   `json:"is_active"`
	StartDate sql.NullTime   `json:"start_date"`
	EndDate   sql.NullTime   `json:"end_date"`
}

func (q *Queries) InsertHomepageBanner(ctx context.Context, arg InsertHomepageBannerParams) (HomepageBanner, error) {
	row := q.queryRow(ctx, q.insertHomepageBannerStmt, insertHomepageBanner,
		arg.ID,
		arg.Title,
		arg.Subtitle,
		arg.MediaID,
		arg.CtaText,
		arg.CtaUrl,
		arg.IsActive,
		arg.StartDate,
		arg.EndDate,
	)
	var i HomepageBanner
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Subtitle,
		&i.MediaID,
		&i.CtaText,
		&i.CtaUrl,
		&i.IsActive,
		&i.StartDate,
		&i.EndDate,
		&i.CreatedAt,
	)
	return i, err
}

const selectAllHomepageBanners = `-- name: SelectAllHomepageBanners :many
SELECT homepage_banners.id, title, subtitle, media_id, cta_text, cta_url, is_active, start_date, end_date, homepage_banners.created_at, media.id, file_name, file_type, mime_type, file_size, url, alt_text, caption, uploaded_by, media.created_at
FROM homepage_banners
INNER JOIN media ON homepage_banners.media_id = media.id
ORDER BY start_date DESC
LIMIT $1 OFFSET $2
`

type SelectAllHomepageBannersParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type SelectAllHomepageBannersRow struct {
	ID          uuid.UUID      `json:"id"`
	Title       sql.NullString `json:"title"`
	Subtitle    sql.NullString `json:"subtitle"`
	MediaID     uuid.NullUUID  `json:"media_id"`
	CtaText     sql.NullString `json:"cta_text"`
	CtaUrl      sql.NullString `json:"cta_url"`
	IsActive    sql.NullBool   `json:"is_active"`
	StartDate   sql.NullTime   `json:"start_date"`
	EndDate     sql.NullTime   `json:"end_date"`
	CreatedAt   sql.NullTime   `json:"created_at"`
	ID_2        uuid.UUID      `json:"id_2"`
	FileName    sql.NullString `json:"file_name"`
	FileType    sql.NullString `json:"file_type"`
	MimeType    sql.NullString `json:"mime_type"`
	FileSize    sql.NullInt64  `json:"file_size"`
	Url         sql.NullString `json:"url"`
	AltText     sql.NullString `json:"alt_text"`
	Caption     sql.NullString `json:"caption"`
	UploadedBy  uuid.NullUUID  `json:"uploaded_by"`
	CreatedAt_2 sql.NullTime   `json:"created_at_2"`
}

func (q *Queries) SelectAllHomepageBanners(ctx context.Context, arg SelectAllHomepageBannersParams) ([]SelectAllHomepageBannersRow, error) {
	rows, err := q.query(ctx, q.selectAllHomepageBannersStmt, selectAllHomepageBanners, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SelectAllHomepageBannersRow{}
	for rows.Next() {
		var i SelectAllHomepageBannersRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Subtitle,
			&i.MediaID,
			&i.CtaText,
			&i.CtaUrl,
			&i.IsActive,
			&i.StartDate,
			&i.EndDate,
			&i.CreatedAt,
			&i.ID_2,
			&i.FileName,
			&i.FileType,
			&i.MimeType,
			&i.FileSize,
			&i.Url,
			&i.AltText,
			&i.Caption,
			&i.UploadedBy,
			&i.CreatedAt_2,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
